## 网络体系结构



![image-20201226202151887](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20201226202151887.png)

##  网络编程

20201221---20201227整理网路编程

### 面试题：

> * 面试题：网络的体系结构分为哪五层，每层分别有哪些协议(阿里面试题) 
>
> * 面试题：讲一下OSI七层模型，每层的作用，问了wifi属于哪一层(百度面试题) 
> * 顺丰面试题：TCP，四次挥手如果改为三次怎么样？ 
> * 大疆面试题：TCP与UDP区别？ 
> * 阿里面试题：TCP和UDP的区别是什么，如果想发送即时消息应该用哪种协议？ 
> * 阿里面试题：TCP的连接建立和断开的过程，如何保证TCP发送的信息是正确的，且保证其先后顺序不被篡改？ 
> * 顺丰面试题：TCP/UDP解释一下？ 
> * 阿里面试题：TCP连接中的三次握手和四次挥手，四次挥手的最后一个ack的作用是什么，为什么要time wait，为什么是2msl。



### 面试题解答：

#### 1、TCP（Transmission Control Protocol）和UDP的区别

（1）TCP面向连接；UDP面向无连接

（2）TCP保证数据正确性；UDP可能丢包

（3）TCP传输速度慢；UDP速度快

（4）每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信

（5）TCP对系统资源要求较多，UDP对系统资源要求较少。

#### 2、三次握手

三次握手的目的是建立可靠的通信信道。确认自己与对方的发送与接收机能正常。 

位码即tcp标志位，有6种标示：

- URG：指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。

- PSH：为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。

- RST：TCP连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。

- FIN：发送端已完成数据传输，请求释放连接。

- SYN：处于TCP连接建立过程。 （Synchronize Sequence Numbers）

- ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

  SYN(synchronous建立联机)  

  ACK(acknowledgement 确认)  

  PSH(push传送) 

   FIN(finish结束) 

   RST(reset重置) 

   URG(urgent紧急)

 Sequence number(顺序号码)  Acknowledge number(确认号码)
![img](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1OTQ4NzE3,size_16,color_FFFFFF,t_70.png)

第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；

第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。



##### TCP三次握手过程:

1、主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ，向主机B请求建立连接,通过这个数据段,主机A告诉主机B两件事：我想要和你通信、你可以用哪个序列号作为起始数据段来回应我。 

2、主机B收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事：我已经收到你的请求了,你可以传输数据了、你要用哪个序列号作为起始数据段来回应我。 

3、主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段：我已收到回复，我现在要开始传输实际数据了。 

这样3次握手就完成了,主机A和主机B 就可以传输数据了. 
![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20210626170932566.png) 

#### 为什么需要三次握手：

三次握手能确认双发收发功能都正常，缺一不可。 

第一次握手：Client什么都不能确认；Server确认了对方发送正常。

第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常。 

第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常。

三次握手的另一个目标是确认确认双方都支持TCP，告知对方用TCP传输。 

第一次握手：Server猜测Client可能要建立TCP请求，但不确定，因为也可能是Client乱发了一个数据包给自己。 

第二次握手：通过ack=J+1，Client知道Server是支持TCP的，且理解了自己要建立TCP连接的意图。 

第三次握手：通过ack=K+1，Server知道Client是支持TCP的，且确实是要建立TCP连接。 

### 3、四次挥手

1、第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了。 

2、第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求。 

3、第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态。 

4、第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 

### 4、为什么要time wait，为什么是2msl

![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20210626170932572.png) 
		

​		为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。 

MSL指的是任何IP数据报能够在因特网上存活的最长时间。假设现在一个MSL的时候，接收端需要发送一个应答，这时候，我们也必须等待这个应答的消失，这个应答的消失也是需要一个MSL，所以我们需要等待2MSL。



### TCP 长连接和短连接有什么区别？

TCP 短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。

而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。

TCP 短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。

TCP 长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。

长短连接的区别就在于客户端和服务端选择的关闭策略不同，具体需要根据应用场景来选择合适的策略。

### TCP 保证数据可靠性的方式大致可以分为三类：

- 在数据包层面：校验和
- 在数据包传输层面：序列号、确认应答、超时重传
- 在流量控制层面：拥塞控制

### TCP 三次握手的目的是什么？为什么不用两次和四次？

#### TCP 三次握手的主要目的是防止失效的连接请求报文被服务端接受

如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。

两次握手只能保证单向链路是可以通信的，理论上来说，要保证双向链路可以通信需要四次握手，但实际上服务端给客户端的 SYN 和 ACK 数据包可以合为一次握手，所以实际上只需要三次握手即可。

#### 加问：那挥手为什么需要四次呢？三次不行吗？

答：挥手阶段中服务端的 ACK 和 FIN 数据包不能合为一次。因为挥手阶段的流程为客户端发送FIN数据包表示自己发完了，服务端立即回复 ACK 数据包表示自己知道了，此时客户端到服务端的连接已经释放了，客户端不会再发送数据了，但服务端还可以继续向客户端发送数据，等到服务端也完成了数据发送，才会发送 FIN，这时客户端回复 ACK，就可以结束通信了。

#### 加问：TCP 在四次挥手的过程中为什么客户端最后还要等待 2MSL(Maximum Segment Lifetime)？

答：因为客户端要保证他的 ACK 包顺利到达服务端，如果客户端的ACK数据包丢失，则服务端或重新发送 FIN 包到客户端，而这两个过程的最长时间为 1MSL，加起来为 2MSL，如果 2MSL 后客户端还没有收到服务端重发的 FIN 包，则说明 ACK 包顺利到达，可以关闭连接了。

## HTTP和HTTPS协议

> **面试题：对HTTP协议了解多少，HTTP和HTTPS有什么区别，HTTPS的安全性是怎么实现的(阿里面试题) 
> 面试题：http解释一下(顺丰面试题)**

**一、HTTP简介** 
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP协议工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求，向客户端发送响应信息。 
**二、HTTP协议特点** 
无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 
无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 

### get请求和post请求区别

1、GET请求一般用去请求获取数据，POST一般作为发送数据到后台时使用

2、GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的，POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制

3、GET 请求可被缓存，POST 请求不会被缓存

4、GET请求只能进行url编码（application/x-www-form-urlencoded），POST支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。）

**三、HTTP之状态码** 
1xx：指示信息–表示请求已接收，继续处理 
2xx：成功–表示请求已被成功接收、理解、接受 
3xx：重定向–要完成请求必须进行更进一步的操作 
4xx：客户端错误–请求有语法错误或请求无法实现 
5xx：服务器端错误–服务器未能实现合法的请求 
常见的状态码：

```properties
200 OK                     //客户端请求成功
400 Bad Request            //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized           //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden              //服务器收到请求，但是拒绝提供服务
404 Not Found              //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error  //服务器发生不可预期的错误
503 Server Unavailable     //服务器当前不能处理客户端的请求，一段时间后可能恢复正常1234567
```

**四、HTTP工作原理** 

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 

以下是 HTTP 请求/响应的步骤： 

**1、客户端连接到Web服务器** 

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.baidu.con](http://www.baidu.con/)。 

**2、发送HTTP请求** 

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

**3、服务器接受请求并返回HTTP响应** 

Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 

**4、释放连接TCP连接** 
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 

**5、客户端浏览器解析HTML内容** 

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 

1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 

2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 

3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 

4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 

5、释放 TCP连接; 

6、浏览器将该 html 文本并显示内容; 　　 

**五、HTTP和HTTPS有什么区别** 

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 
HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 

**HTTPS和HTTP的区别主要如下：** 

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 

**六、HTTPS的安全性是怎么实现的 **
![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20201226201139722.png) 

（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 

（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 

（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 

（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 

（5）Web服务器利用自己的私钥解密出会话密钥。 

（6）Web服务器利用会话密钥加密与客户端之间的通信。 

![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20201226201139760.png)

### 专业名词：

#### 什么是2MSL？

​		MSL是*Maximum Segment Lifetime*英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为*tcp*报文（*segment*）是*ip*数据报（*datagram*）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而*ip*头中有一个*TTL*域，*TTL*是*time to live*的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个*ip*数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减*1*，当此值为*0*则数据报将被丢弃，同时发送*ICMP*报文通知源主机。

*RFC 793*中规定*MSL*为*2*分钟，实际应用中常用的是*30*秒，*1*分钟和*2*分钟等。

2MSL即两倍的*MSL*，*TCP*的*TIME_WAIT*状态也称为*2MSL*等待状态，当*TCP*的一端发起主动关闭，在发出最后一个*ACK*包后，即第*3*次握手完成后发送了第四次握手的*ACK*包后就进入了*TIME_WAIT*状态，必须在此状态上停留两倍的*MSL*时间，等待*2MSL*时间主要目的是怕最后一个*ACK*包对方没收到，那么对方在超时后将重发第三次握手的*FIN*包，主动关闭端接到重发的*FIN*包后可以再发一个*ACK*应答包。在*TIME_WAIT*状态时两端的端口不能使用，要等到*2MSL*时间结束才可继续使用。当连接处于*2MSL*等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置*SO_REUSEADDR*选项达到不必等待*2MSL*时间结束再使用此端口。*TTL*与*MSL*是有关系的但不是简单的相等的关系，*MSL*要大于等于*TTL*。



[详解TCP](



### pc一次请求的流程

1. 根据域名找服务器ip，首先根据host判断，如果host存在，直接使用该ip。
2. 如果host不存在，走dns服务器，电脑配置的dns，如果没有配置走默认的dns，一般是运营商的dns服务器。
3. 通过dns找到ip，访问ip，进行tcp握手等操作。

**面试题：网络的体系结构分为哪五层，每层分别有哪些协议(阿里面试题) 
面试题：讲一下OSI七层模型，每层的作用，问了wifi属于哪一层(百度面试题)** 

###  一、OSI七层模型（Open System Interconnection）开放式系统互联

![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20201226194559036.png) 

**应用层** 
	是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 

**表示层** 
	表示提供各种用于应用层数据编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 

**会话层** 
	会话层负载建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 

**传输层** 
	传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，是高层用户看到的只是在两个传输实体建的一个主机到主机的、可由用户控制和设定、可靠的数据通路。通常说的TCP UDP就是在这层。端口号即是这里的“端”。 

**网络层** 
	本层通过IP寻址来建立两点之间的连接，为源端的运输层来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的ip层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

**数据链路层** 
	将比特组合成字节，再将字节组成帧，使用链路层地址（以太网mac地址）来访问介质，并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。 

**物理层** 
	主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 

### **二、TCP/IP四层模型**

![这里写图片描述](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/70-20201226194558896.png) 

### **三、Wifi和zigbee**

zigbee和wifi符合局域网标准，是工作在OSI数据链路层和物理层的。



* ![image-20201223224325470](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20201223224325470.png)

  ![image-20201223223829874](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20201223223829874.png)

==自言自语：==TCP/IP模型：分为四层：应传网链，对应OSI的七层协议，（3+1+1+2）



