# 三次握手

在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用[三次握手](http://baike.baidu.com/link?url=eZXiFRQOKsO6NUMErlv_ourWMexrPfxtUhSw1f5waWf_gVDDeOpI7xFga2VygpC-qZWFVkj-XTcQeKx7UQO7fq)建立一个连接。

![img](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/20150603155505255.png) 


**第一次握手**：建立连接时，客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认； 

**第二次握手**：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态； 

**第三次握手**：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

![img](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/20150511164615901.jpeg) 


通过这样的[三次握手](http://baike.baidu.com/link?url=eZXiFRQOKsO6NUMErlv_ourWMexrPfxtUhSw1f5waWf_gVDDeOpI7xFga2VygpC-qZWFVkj-XTcQeKx7UQO7fq)，客户端与服务端建立起可靠的双工的连接，开始传送数据。 **三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。**但是为什么一定要进行三次握手来保证连接是双工的呢，一次不行么？两次不行么？



我们举一个现实生活中两个人进行语言沟通的例子来模拟[三次握手](http://baike.baidu.com/link?url=eZXiFRQOKsO6NUMErlv_ourWMexrPfxtUhSw1f5waWf_gVDDeOpI7xFga2VygpC-qZWFVkj-XTcQeKx7UQO7fq)。



**第一次对话：** 
老婆让甲出去打酱油，半路碰到一个朋友乙，甲问了一句：哥们你吃饭了么？ 


结果乙带着耳机听歌呢，根本没听到，没反应。甲心里想：跟你说话也没个音，不跟你说了，沟通失败。说明乙接受不到甲传过来的信息的情况下沟通肯定是失败的。

 
如果乙听到了甲说的话，那么第一次对话成功，接下来进行第二次对话。 


**第二次对话：** 
乙听到了甲说的话，但是他是老外，中文不好，不知道甲说的啥意思也不知道怎样回答，于是随便回答了一句学过的中文 ：我去厕所了。甲一听立刻笑喷了，“去厕所吃饭”?道不同不相为谋，离你远点吧，沟通失败。说明乙无法做出正确应答的情况下沟通失败。 


如果乙听到了甲的话，做出了正确的应答，并且还进行了反问：我吃饭了，你呢？那么第二次握手成功。 


通过前两次对话证明了乙能够听懂甲说的话，并且能做出正确的应答。接下来进行第三次对话。 


**第三次对话：** 
甲刚和乙打了个招呼，突然老婆喊他，“你个死鬼，打个酱油咋这么半天，看我回家咋收拾你”，甲是个妻管严，听完吓得二话不说就跑回家了，把乙自己晾那了。乙心想：这什么人啊，得，我也回家吧，沟通失败。说明甲无法做出应答的情况下沟通失败。 


如果甲也做出了正确的应答：我也吃了。那么第三次对话成功，两人已经建立起了顺畅的沟通渠道，接下来开始持续的聊天。 


通过第二次和第三次的对话证明了甲能够听懂乙说的话，并且能做出正确的应答。 可见，两个人进行有效的语言沟通，这三次对话的过程是必须的。

 
**同理对于TCP为什么需要进行三次握手我们可以一样的理解：** 
为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 



# 四次挥手

[由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭](http://baike.baidu.com/link?url=8_DsYi4pjWpNRFrSX10jiGxe0PLruypbRhv4o56eXOi07tQPokeFgnt1_leXVDy7ELc-uR4_E1cr1NfV3lJUYK)。这好比，我们打电话（全双工），正常的情况下（出于礼貌），通话的双方都要说再见后才能挂电话，***\*保证通信双方都把话说完了才挂电话\****。

![img](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/20150603155718772.jpeg)



那[TCP 的四次握手](http://baike.baidu.com/link?url=8_DsYi4pjWpNRFrSX10jiGxe0PLruypbRhv4o56eXOi07tQPokeFgnt1_leXVDy7ELc-uR4_E1cr1NfV3lJUYK)，**是为了保证通信双方都关闭了连接**，具体过程如下：

![img](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/20150603155803953.png)





1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送；
2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；
3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A；
4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。



![img](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/20150511172829813.jpeg)



***\*为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？\****

这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，也有这么种可能，你还有一些数据在传给对方的途中，所以你不能立马关闭连接,也即你可能还需要把在传输途中的数据给对方之后，又或者，你还有一些数据需要传输给对方后，（再关闭连接）再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。



***\*为什么 TIME_WAIT 状态还需要等 2MS L后才能返回到 CLOSED 状态？\****

这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。（[里面涉及的状态是什么意思，详情请看《TCP 通信过程中各步骤的状态》](http://blog.csdn.net/tennysonsky/article/details/45646561)）