# [支付宝蚂蚁金服怎么在分布式架构下保证转账业务数据的一致性？](https://www.yubaibai.com.cn/article/25391.html)

 作者：肖钦  2019-03-27 15:02

# 概述

本文以分布式架构下的转账服务为业务场景，先阐述分布式架构下跨数据库转账遇到的数据一致性问题；再详细介绍如何使用行业常见的分布式事务解决方案（`消息事务、冲正补偿、JTA/XA`），以及`蚂蚁的分布式事务（DTX）`，解决跨库转账的数据一致性问题，并列举了各种解决方案的优劣势。

通过对比各种分布式事务解决方案，您会发现，分布式事务有丰富的接入模式，能应对各种复杂的业务场景，接入维护简单，性能优异，行业优势明显。

# 需求背景和技术问题

## 需求描述

转账是金融机构日常业务中的常见场景。假设用户 A为转账发起方，从自己的账户余额中转出一笔资金至用户 B 的账户中。此操作涉及两部分：“A 账户的扣钱”和“B 账户的加钱”，这两个操作要都成功才算转账成功。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505004641-0.jpg)

▲ 用户 A 向用户 B 转账

如果一个操作成功而另一个操作失败（比如：B 账户加钱成功，A 账户扣钱失败），则会出现总体资金数据不一致，造成资金损失；故转账服务的中的“加钱”和“扣钱”操作必须在一个事务内，要么都成功，要么都失败。

在非分布式架构下，用户 A、用户 B 的账户数据都在同一个数据库中，可以使用数据库事务来保证“加钱”和“扣钱”操作的在一个事务内。

但是在分布式架构下，用户 A 的账户数据、用户 B 的账户数据会分别存储在不同数据库中，此时便无法再使用数据库事务来保证“加钱”和“扣钱”操作的原子性，需要考虑能保证数据一致性的解决方案。

## 需求分析

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/150500C21-1.png)

▲ 用户 A 发起转账业务

如上图所示，在分布式架构下，用户 A 发起转账操作，向用户 B 转账 100 元。

转账过程中，首先是在数据库 A 中扣除账号 A 的 100 元，紧接着是在数据库 B 中给账户 B 加 100 元。

“数据库 A 上账户 A 扣款操作”、“数据库 B 上账户 B 加钱操作”都成功才算转账成功；如果一个操作成功，另一操作失败（比如：账户 B 加钱成功，账户 A 扣钱失败），则会出现资金数据不一致，造成资金损失；如果加钱操作和扣钱操作丢失败，那么转账是失败的，但是不会有资金损失。

故需要保证数据库 A、数据库 B 上的更新操作都成功或者都失败；整个资金数据最终是一致的。

## 技术问题

分布式架构下，用户 A、用户 B 的账户数据存储在不同的数据库中，需要引入能保证跨数据库的多个操作在一个事务内的解决方案，以保证转账操作的原子性，保障跨库转账时的资金安全。

下文将介绍目前常见的分布式事务解决方案，并将其应用到转账场景，以解决跨库转账时的数据一致性问题。

# 行业分布式事务解决方案

分布式事务是指事务中资源分布于网络中的多个不同节点的事务。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505005O1-2.jpg)

▲ 分布式事务中的`事务管理器与资源管理器`

如上图所示，分布式事务有一个事务管理器（Transaction Manager）和多个资源管理器（Resource Manager）组成：

- 事务管理器：通常被称为事务发起方，负责发起方分布式事务，编排、协调所有资源管理器完成业务活动。

- 资源管理器：也被称为事务参与者，对应单个业务动作，由事务管理器协调、编排。

 在本文的转账案例中，转账服务便是事务管理器（发起方），转账服务内部执行“扣钱”、“加钱”动作是事务的参与者。

二阶段提交协议（2PC）是分布式事务的基础协议，在此协议中，事务管理器分两个阶段协调资源管理器。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505003R4-3.jpg)

▲ 二阶段提交

如上图所示，在第一阶段，事务管理器向所有资源管理器发生准备请求，如果所有资源管理返回准备成功，那么在第二阶段事务管理器向所有资源发生提交请求，完成所有资源的提交。

如果有任一资源管理一阶段准备失败，那么在第二阶段事务管理器向所有资源发生回滚请求，完成所有资源的回滚。

`目前常见的分布式事务解决方案均采用二阶段提交协议实现。`

下文将以转账场景为例，分别介绍非事务解决方案和常见的分布式事务解决方案，了解它们是如何保障分布式架构下跨库转账的原子性，保障资金数据的一致性。

## 0、非事务解决方案

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505005539-4.jpg)

▲ 转账操作流程

如上图所示，在非分布式事务解决方案中，转账操作会依次执行“A 账户扣除 100 元”、“B 账户增加 100 元”，最后完成转账操作。整个转账操作内部有两个操作，分别是：“A 账户扣钱”、“B 账户加钱”，我们把这两个操作抽象成扣钱服务（MinusAction）和加钱服务（AddAction）：

- 扣钱服务：负责在 A 账户余额上扣除转账资金。

- 加钱服务：负责向 B 账户加钱。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505005L0-5.jpg)

▲ 转账服务流程

如上图所示，转账服务会依次调用 MinusAction 服务的 minus 方法完成 A 账户的扣款，AddAction 服务的 add 方法完成 B 账户的加钱。整个转账过程中，未引入任何分布式事务解决方案来保证转账操作（加钱操作、扣钱操作）的原子性。正常情况下，加钱操作和扣钱操作都执行成功，这种实现方式不会有问题。但是在异常情况下（比如：A 账户扣钱成功，但是 B 账户加钱失败，此时 A 账户扣掉的钱将无法恢复），会出现资金数据不一致，给用户造成资金损失。因此，在金融行业，这种解决方案是不可取的，必需引入分布式事务解决方案来保障转账服务的原子性。

## 一、消息事务解决方案

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/150500OV-6.jpg)

▲ 消息事务业务流程

消息事务是一种比较常见的分布式事务解决方案。如上图所示，引入了消息事务解决方案来解决转账操作的事务问题。

转账服务内部使用消息事务功能，发送加钱消息给加钱服务，同时在消息事务回调方法内调用扣钱服务完成 A 账户的扣钱；A 账户扣钱成功则加钱消息发送成功，否则加钱消息发送失败；消息发送完成之后，转账服务返回结果，消息事务一阶段完成。

在第二阶段订阅消息，消息消费时，调用加钱服务完成 B 账户的加钱；B 账户加钱成功则消息消费成功；否则消息消费失败，消息队列下个周期重试投递消息。

### 消息事务解决方案分析

- 消息事务的转账操作分为两个阶段，在一阶段执行的操作是：“A 账户扣除 100 元钱”和发送“B 账户加钱”消息至消息队列，这两个操作要么都成功，要么都失败。

- 在一阶段结束之后，整个转账操作便结束，用户会收到转账结果；此时用户会认为转账完成。

- 二阶段“B 账户加钱”消息的消费是异步的，由消息队列将“B 账户加钱”消息发送至“B 账户扣钱”服务，此服务消费消息并完成账户 B 的加钱；消息队列会一直重复投递消息，直到“B 账户加钱”成功为止。

### 消息事务解决方案问题

- 消息消费延迟。一阶段“A 账户扣款”之后，转账操作便结束，此时用户认为转账操作已经完成；但实际上“B 账户加钱操作”未执行；需要等待消息队列投递“B 账户加钱”消息方可执行，消息投递延迟时间是不确定的，造成“B 账户加钱操作”执行实际不确定。

- 要求二阶段的消息消费必须 100% 成功。一阶段“账户 A 扣除 100 元钱”成功之后，如果二阶段“账户 B 加钱 100 元钱操作”无法成功（比如：账户 B 不存在、B账户被冻结等原因导致账户 B 加钱永远不会成功），此时整个资金就处于不一致状态，账户 A 扣除的 100 元钱将永远无法得到补偿；所以使用消息事务必须保证二阶段的消息消费一定能成功。

- 引入“消息队列”风险点。消息事务可用的前提是消息队列可用。消息队列宕机会导致整个转账操作完全不可用；消息队列出现消息积压会导致二阶段延迟更加严重。因此，消息队列可能成为消息事务解决方案的一个潜在瓶颈。

## 二、冲正补偿解决方案

冲正补偿也是分布式事务比较常用的一种解决方案，冲正补偿可以解决消息事务二阶段不可逆的问题。

各个业务参与者（加钱、扣钱动作）需要分别实现正向业务操作，以及其逆向回滚操作。

事务协调者先执行所有参与者正向业务操作，如果所有参与者正向操作均成功，那么整个业务就算成功；如果任意参与者正向操作执行失败，那么协调者会去执行所有参与者的逆向操作，让事务回滚。转账的冲正补偿实现如下图所示：

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/150500M02-7.jpg)

▲ 冲正补偿业务流程

冲正补偿解决方案中，每一个业务操作均需要实现正向和逆向两个操作；对于扣钱服务，除了扣钱操作外，还需要实现其方法的回滚操作；对于加钱服务，除了加钱操作外，还需要实现其回滚操作。

### 冲正补偿解决方案分析

- 在冲正补偿下，各服务均需要用户设计和实现“正向”和“逆向”两个操作。

- 转账操作开始之后，先执行 A 账户的正向操作“A 账户扣钱操作”，如果执行失败，则执行逆向操作“A 账户扣钱回滚操作”，最终转账操作失败。

- 如果 A 账户正向操作成功，则执行 B 账户的正向操作“B账户加钱操作”；如果“B 账户加钱”执行失败，则会执行 B 账户逆向操作“B账户加钱回滚操作”，以及 A 账户的逆向操作“A 账户扣钱回滚操作”，最终转账失败。

- 如果 A 账户正向和 B 账户的正向操作均成功，那么转账成功。

### 冲正补偿解决方案问题

- 接入成本高。冲正补偿需要用户设计实现各服务的正向和逆向操作，用户在设计正向操作时，需要同时考虑逆向操作该如何执行；需要在正向操作中保存一些中间数据，供逆向操作运行时使用，系统设计实现较复杂。

- 资金安全问题。假如在某些场景下，对 B 账户“加钱”（正向）成功之后，出现一些其他异常导致整个转账操作需要回滚，此时会触发“加钱”操作的逆向操作去扣除 B 账户上的资金；但是如果 B 用户在此之前已经把账户上的资金全部转走，“扣除 B 账户上的资金”这个逆向操作可能永远不会成功，此时就出现资金无法追回的问题。为了解决资金安全问题，编排冲正补偿各动作时，需要考虑如何保障资金安全；系统设计的方方面面均需考虑资金安全，无疑系统设计会复杂繁琐，日后的代码维护也需谨慎。

- 维护成本高。正向、逆向操作执行过程中，可能出现服务器宕机、重启等异常情况导致转账流程中断（比如正向操作中，A账户扣钱成功之后，B 账户加钱还未开始，执行流程中断），此时就需要用户维护一个恢复程序，不断找到这种未完成的转账任务，执行该笔转账剩余的未完成的操作，使转账成功或者转账回滚，以保障数据的最终一致。但目前冲正补偿并没有标准的恢复程序可用，这个恢复程序就需要用户自己设计实现，成本较高。

## JTA/XA 解决方案

JTA/XA 解决方案通过 JTA API 调用数据库的 XA 接口，协调各个数据库上的 XA 事务的提交和回滚。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505005495-8.jpg)

▲ JTA/XA 业务流程

如上图所示，加钱操作、扣钱操作分别调用数据库 A、数据库 B 的 JTA/XA API。JTA/XA API 能帮助用户分二阶段协调各个数据库上 XA 事务的同步提交和回滚。

### JTA/XA 解决方案分析

- 用户编写 JTA 接口，内部分别开启“A 数据库”、“B 数据库”上的 XA 事务。

- 开启 XA 事务之后，分别在“A 数据库”XA 事务上执行 A 账户扣钱任务，在“B 数据库”XA 事务中执行 B 账号加钱任务；并结束 XA 事务。

- 执行 XA 事务一阶段的预提交。

- 如果“A 数据库”、“B 数据库”上的 XA 事务预提交均成功，则提交 XA 事务。

- 如果“A 数据库”、“B 数据库”上的 XA 事务预提交出现失败，则回滚 XA 事务。

JTA/XA 解决方法下，数据库 XA 事务作为资源管理器，用户自己作为事务协调者，调用 JTA 接口操作 XA 事务。

### JTA/XA 解决方案的问题

- XA 并发性能受限。XA 事务内访问的数据都会被数据库加锁，直到 XA 事务提交或者回滚，这些数据锁才会被释放。这个数据库层的全局锁限制了 XA 事务的并发性，极大影响了 XA 事务的性能。

- 运维成本高。与冲正补偿一样，XA 解决方案下，事务协调者执行转账操作的任意阶段，都可能出现服务器宕机、重启等异常情况导致转账流程中断，此时就需要用户维护一个恢复程序，不断找到这种未完成的转账任务，执行该笔转账剩余的未完成的操作，使转账成功或者转账回滚，以保障数据的最终一致。

  同样的，JTA/XA 解决方案并没有标准的恢复程序可用，这个恢复程序就需要用户自己设计实现，成本较高。

# 蚂蚁金服分布式事务解决方案

前文介绍了消息事务、冲正补偿等解决方案及其问题，接下来我们将介绍使用蚂蚁金服的分布式事务（DTX）解决方案来实现转账操作。

分布式事务有两种模式：TCC 模式和 FMT 模式：

- TCC 模式由用户实现 TCC 参与者，供事务发起方协调。

- FMT 模式无需用户实现 TCC 参与者，用户的业务将作为一阶段操作，每一个业务的二阶段操作由分布式事务框架自动生成。

下面我们将分别介绍如何使用 TCC 模式、FMT 模式实现转账操作。

## TCC 模式解决方案

TCC 即 Try-Confirm-Cancel 的缩写，是服务化的二阶段提交（2PC）编程模型：

- Try：资源检查和预留

- Confirm：发生实际的业务操作；要求 Try 成功 Confirm 一定能成功

- Cancel：预留资源的释放，Try 阶段的逆向操作

TCC 模式需要用户将“A 账户扣钱”、“B 账户加钱”均分成二阶段实现，在第一阶段检查预留资源，在二阶段提交时执行实际的扣钱、加钱操作，二阶段回滚时释放预留资源。

使用分布式事务的 TCC 模式，需要用户设计、实现个业务动作的 TCC 服务，此 TCC 服务有 3 个方法，分别是一阶段的准备方法（Try）、二阶段的提交方法（Confirm）和二阶段的回滚方法（Cancel）。

![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/1505004955-9.jpg)

▲ 转账 TCC 业务流程

如上图所示，TCC 模式的转账操作描述：

- 转账操作内，首先执行各 TCC 参与者的一阶段方法，做转账准备操作；一阶段准备成功，则二阶段的提交一定能成功。

- 如果所有一阶段参与者方法均执行成功，那么二阶段转账操作会去执行所有 TCC 参与者的提交方法，执行 A 账户的扣钱和 B 账户的加钱，完成真正用户余额的转账。

- 如果一阶段有任一参与者出现失败，那么二阶段便会执行所有 TCC参与者的回滚方法，使得各账户恢复至转账前的状态。

在转账方法内部，用户只需要显示调用各个参与者（A 账户扣钱参与者、B 账户加钱参与者）的一阶段方法，无需关注参与者的二阶段方法调用（参与者二阶段方法由分布式事务框架来调用，分布式事务框架会根据转账方法返回结果是成功还是失败，来决定是去调用各参与者二阶段的提交方法还是回滚方法）。

### TCC 模式优点

- 无资金安全风险。一阶段只会冻结转账资金，不会发生真正的资金转账。一阶段成功之后才回去执行二阶段的提交操作，完成真正的资金转账；与冲正补偿相比，TCC 模式资金更加安全。

- 运维成本低；在转账操作执行过程中出现异常中断时，TCC 模式无需用户自己维护异常事务恢复程序，分布式事务提供了标准的统一的恢复服务帮助用户恢复异常事务；这个恢复服务用户完全无感知。

- 性能优越。TCC 参与者各阶段方法由用户实现；相对于 XA 这种数据库层的全局锁，用户可自定义其数据库的操作粒度，使数据库层面的锁冲突最小、最大限度的提高吞吐量。

### TCC 模式问题

接入成本较高。用户接入过程中，需要考虑如何将业务动作分成二阶段完成，需要在第一阶段预留资源，以保证第二阶段的提交一定能成功。此外，TCC 参与者实现时还需要考虑幂等控制、防悬挂等，这些都增加了 TCC 模式的接入成本。

## FMT 模式解决方案

针对 TCC 模式接入成本高的问题，分布式事务开发了 FMT 模式。FMT 模式的接入成本极低，用户无需实现 TCC 参与者，只需要极少的改动业务代码即可接入分布式事务。

### FMT 模式优点

接入简单、快捷；对业务代码改动少。

### FMT 模式问题

在实现上，为了防止数据的无效读写等问题，添加了行锁；相对于几乎无锁的 TCC 模式，性能稍弱。

# 分布式事务与行业解决方案对比

## 与消息事务相比

- 消息事务存在消息消费延迟的问题；分布式事务所有操作均是同步调用，无任何延迟。

- 消息事务在一阶段成功后，要求二阶段的消息消费必须成功。分布式事务的 TCC 模式也是二阶段操作，但在一阶段准备操作后，可以保证二阶段一定成功；而 FMT 模式在一阶段准备操作后，会自动生成二阶段操作，可以保证操作 100% 成功。

- 消息事务依赖消息队列服务；分布式事务不依赖任何第三方服务。

## 与冲正补偿相比

- 冲正补偿要求各个业务动作均实现“正向”、“逆向”2 个操作；TCC 要求业务动作分 2 阶段实现，分别是一阶段的准备，和二阶段的提交/回滚。对于接入成本来说，二者可以说的等价的。但是FMT 模式下，无需用户实现这些复杂操作，用户只需按自身业务逻辑实现其代码。

- 冲正补偿在正向操作中就完成用户账户资金的修改，存在资金安全风险；TCC 模式一阶段只是冻结资金，二阶段才完成真正的资金变更，无资金安全问题；FMT 模式有全局行锁对用户数据进行加锁，用户在转账事务未完成前，无法动用账户资金，同样无资金安全问题。

- 冲正补偿需要用户维护一个事务的恢复服务；而分布式事务提高了统一的标准的异常恢复程序，分布式事务维护成本更低。

## 与 JTA/XA 相比

- TCC 模式可以认为是无任何数据库层面的全局数据锁，性能比 XA 高很多；FMT 模式虽然有类 XA 的全局数据锁，但是我们对 FMT 的行锁做了大量优化，引入乐观锁、自旋锁、控制行锁粒度等优化策略，FMT 的行锁性能比 XA 稍高。

- JTA/XA 解决方案需要用户维护一个事务的恢复服务；而分布式事务提高了统一的标准的异常恢复程序，维护成本更低。

## 总结

相较于消息事务、冲正补偿、JTA/XA 等解决方案，分布式事务提供了多种模式和解决方案，在性能、易用性、运维成本等方面均有较出色的表现，是目前行业内领先的分布式事务解决方案。

分布式事务提供了两种模式：TCC 模式、FMT 模式。如果比较看重易用性，可以选择使用 FMT 模式；如果业务逻辑比较复杂，对性能要求比较高，可以选择 TCC 模式。

原创日期：2018-04-04

原文作者：绍辉









---

# [一次给女朋友转账引发我对分布式事务的思考](https://www.cnblogs.com/sujing/p/11006424.html)

> 本文在个人技术博客不同步发布，详情可[**用力戳**](http://www.17coding.info/article/20)
> 亦可扫描屏幕右侧二维码关注个人公众号，公众号内有个人联系方式，等你来撩...

   前两天发了工资，第一反应是想着要给远方的女朋友一点惊喜！于是打开了平安银行的APP给女朋友转点钱！填写上对方招商银行卡的卡号、开户名，一键转账！搞定！在我点击的那瞬间，就收到了app的账户变动的提醒，并且出现了图一所示的提示界面：“处理中，正在等待对方银行返回结果…”。嗯！毕竟是跨行转账嘛，等个几秒也正常！脑海开始浮现出女朋友收到转账后惊喜与感动的画面！

   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190416211531.png)

   然而，一切并没有那么顺利，刚过一会儿，app却如图二所示的提示我“由于收款人户名不符”导致转账失败！！！

   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190416211546.png)

   刚刚都已经从我卡里扣过钱了，现在却提示我转账失败，银行会不会把我的钱给吞了？转账失败的钱还能退换给我吗？正在我紧张、焦虑、坐立不安之时又收到一条app冲正的消息，刚刚转账失败的钱已经退还给我了，看来我多虑了……这也证明咱平安银行的app还是比较安全靠谱的！

   为啥从我卡里扣钱那么迅速，而对方却要几秒才能到账？并且转账失败后，扣除的钱还能及时的返还到我的卡里？万一钱返还失败怎么办？又或者我转一次钱，对方却收到了两次转账的申请又该如何？带着这些问题，我脑海中浮现出“事务”二字！

   在我们还在“牙牙学语”的时候，老师经常会通过转账的栗子来跟我们讲解事务，但跟这里场景不一样的是，老师讲的是本地事务，而这里面对的是分布式事务！我们先来简单回顾一下本地事务！

## 本地事务

   谈到本地事务，大家可能都很熟悉，因为这个数据库引擎层面能支持的！所以也称数据库事务，数据库事务四大特征：原子性（A），一致性（C），隔离性（I）和持久性（D），而在这四大特性中，我认为**一致性**是最基本的特性，其它的三个特性都为了保证一致性而存在的！

   回到学生时代老师给我们举的经典栗子，A账户给B账户转账100元（A、B处于同一个库中），如果A的账户发生扣款，B的账户却没有到账，这就出现了**数据的不一致**！为了保证数据的一致性，数据库的事务机制会让A账户扣款和B在账户到账的两个操作要么同时成功，如果有一个操作失败，则多个操作同时回滚，这就是事务的**原子性**，为了保证事务操作的原子性，就必须实现基于日志的REDO/UNDO机制！但是，仅有原子性还不够，因为我们的系统是运行在多线程环境下，如果多个事务并行，即使保证了每一个事务的原子性，仍然会出现数据不一致的情况。例如A账户原来有200元的余额， A账户给B账户转账100元，先读取A账户的余额，然后在这个值上减去100元，但是在这两个操作之间，A账户又给C账户转账100元，那么最后的结果应该是A减去了200元。但事实上，A账户给B账户最终完成转账后，A账户只减掉了100元，因为A账户向C账户转账减掉的100元被覆盖了！所以为了保证并发情况下的一致性，又引入的**隔离性**，即多个事务并发执行后的状态，和它们串行执行后的状态是等价的！隔离性又有多种隔离级别，为了实现隔离性（最终都是为了保证一致性）数据库又引入了悲观锁、乐观锁等等……本文的主题是分布式事务，所以本地事务就只是简单回顾一下，需要记住的一点是，事务是为了保证数据的**一致性**！

## 分布式理论

  还记得刚毕业那年，带着满腔的热血就去到了一家互联网公司，领导给我的第一个任务就是在列表上增加一个修改数据的功能。这能难倒我？我分分钟给你搞出来！不就是在列表上增加了一个“修改”按钮，点击按钮弹出框修改后保存就好了么。然而一切不像我想象的那么顺利，点击保存并刷新列表后，页面上的数据还是显示的修改之前的内容，像没有修改成功一样！过一会儿再刷新列表，数据就能正常显示了！测试多次之后都是这样！没见过什么大场面的我开始有点慌了，是我哪里写得不对么？最终，我不得不求助组内经验比较丰富的前辈！他深吸了一口气告诉我说：“毕竟是刚毕业的小伙子啊！我来跟你讲讲原因吧！我们的数据库是做了读写分离的，部分读库与写库在不同的网络分区。你的数据更新到了写库，而读数据的时候是从读库读取的。更新到写库的数据同步到读库是有一定的延迟的，也就是说读库与写库会有短暂的数据不一致”！ “这样不会体验不好么？为什么不能做到写入的数据立马能读出来？那我这个功能该怎么实现呢？” 面对我的一堆问题，同事有些不耐烦的说：“听说过CAP理论吗？你先自己去了解一下吧”！是我开始查阅各种资料去了解这个陌生的词背后的秘密！

  `CAP理论`是由加州大学Eric Brewer教授提出来的，这个理论告诉我们，一个分布式系统不可能同时满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)这三个基本需求，最多只能同时满足其中两项。
  **一致性**：这里的一致性是指数据的强一致，也称为线性一致性。是指在分布式环境中，数据在多个副本之间是否能够保持一致的特性。也就是说对某个数据进行写操作后立马执行读操作，必须能读取到刚刚写入的值。（any read operation that begins after a write operation completes must return that value, or the result of a later write operation）
  **可用性**：任意被无故障节点接收到的请求，必须能够在有限的时间内响应结果。（every request received by a non-failing node in the system must result in a response）
  **分区容错性**：如果集群中的机器被分成了两部分，这两部分不能互相通信，系统是否能继续正常工作。（the network will be allowed to lose arbitrarily many messages sent from one node to another）

  在分布式系统中，分区容错性是基本要保证的。也就是说只能在一致性和可用性之间进行取舍。一致性和可用性，为什么不可能同时成立？回到之前修改列表的例子，由于数据会分布在不同的网络分区，必然会存在数据同步的问题，而同步会存在网络延迟、异常等问题，所以会出现数据的不一致！如果要保证数据的一致性，那么就必须在对写库进行操作时，锁定其他读库的操作。只有写入成功且完成数据同步后，才能重新放开读写，而这样在锁定期间，系统丧失了可用性。更详细关于CAP理论可以参考[这篇文章](https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/)，该文章讲得比较通俗易懂！

## 分布式事务

   分布式事务就是在分布式的场景下，需要满足事务的需求！上篇文章我们聊过了消息中间件，那这篇文章我们要聊的是分布式事务，把两者一结合，便有了基于消息中间件的分布式事务解决方案！不管是本地事务，还是分布式事务，都是为了解决数据的一致性问题！**一致性**这个词咱们前面多次提及！与本地事务不同的是，分布式事务需要保证的是分布式环境下，不同数据库表中的数据的一致性问题。分布式事务的解决方案有多种，如XA协议、TCC三阶段提交、基于消息队列等等，本文只会涉及基于消息队列的解决方案！

   本地事务讲到了一致性，分布式事务不可避免的面临着一致性的问题！回到最开始跨行转账的例子，如果A银行用户向B银行用户转账，正常流程应该是：

> 1、A银行对转出账户执行检查校验，进行金额扣减。
> 2、A银行同步调用B银行转账接口。
> 3、B银行对转入账户进行检查校验，进行金额增加。
> 4、B银行返回处理结果给A银行。

   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190611201950.png)

   在正常情况对一致性要求不高的场景，这样的设计是可以满足需求的。但是像银行这样的系统，如果这样实现大概早就破产了吧。我们先看看这样的设计最主要的问题：

> 1、同步调用远程接口，如果接口比较耗时，会导致主线程阻塞时间较长。
> 2、流量不能很好控制，A银行系统的流量高峰可能压垮B银行系统（当然B银行肯定会有自己的限流机制）。
> 3、如果“第1步”刚执行完，系统由于某种原因宕机了，那会导致A银行账户扣款了，但是B银行没有收到接口的调用，这就出现了两个系统数据的不一致。
> 4、如果在执行“第3步”后，B银行由于某种原因宕机了而无法正确回应请求（实际上转账操作在B银行系统已经执行且入库），这时候A银行等待接口响应会异常，误以为转账失败而回滚“第1步”操作，这也会出现了两个系统数据的不一致。

   对于问题的1、2都很好解决，如果对消息队列熟悉的朋友应该很快能想到可以引入消息中间件进行异步和削峰处理，于是又重新设计了一个方案，流程如下：

> 1、A银行对账户进行检查校验，进行金额扣减。
> 2、将对B银行的请求异步写入队列，主线程返回。
> 3、启动后台程序从队列获取待处理数据。
> 4、后台程序对B银行接口进行远程调用。
> 5、B银行对转入账户进行检查校验，进行金额增加。
> 6、B银行处理完成回调A银行接口通知处理结果。

   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190417210335.png)

   通过上面的图我们能看到，引入消息队列后，系统的复杂性瞬间提升了，虽然弥补了我们第一种方案的几个不足点，但也带来了更多的问题，比如消息队列系统本身的可用性、消息队列的延迟等等！并且，这样的设计依然没有解决我们面临的核心问题-**数据的一致性**！

> 1、如果“第1步”刚执行完，系统由于某种原因宕机了，那会导致A银行账户扣款了，但是写入消息队列失败，无法进行B银行接口调用，从而导致数据不一致。
> 2、如果B银行在执行“第5步”时由于校验失败而未能成功转账，在回调A银行接口通知回滚时网络异常或者宕机，会导致A银行转账无法完成回滚，从而导致数据不一致。

   面对上述问题，我们不得不对系统再次进行升级改造。为了解决“A银行账户扣款了，但是写入消息队列失败”的问题，我们需要借助一个转账日志表，或者叫转账流水表，该表简单的设计如下：

| 字段名称        | 字段描述                               |
| --------------- | -------------------------------------- |
| tId             | 交易流水id                             |
| accountNo       | 转出账户卡号                           |
| targetBankNo    | 目标银行编码                           |
| targetAccountNo | 目标银行卡号                           |
| amount          | 交易金额                               |
| status          | 交易状态（待处理、处理成功、处理失败） |
| lastUpdateTime  | 最后更新时间                           |

   这个流水表需要怎么用呢？我们在“第1步”进行扣款时，同时往流水表写入一条操作流水，状态为“待处理”，并且这两个操作必须是原子的，也就是说必须通**过本地事务保证**这两个操作要么同时成功，要么同时失败！这就保证了只要转账扣款成功，必定会记录一条状态为“待处理”的转账流水。如果在这一步失败了，那自然就是转账失败，没有后续操作了。如果这步操作后系统宕机了导致没有将消息成功写入消息队列（也就是“第2步”）也没关系，因为我们的流水数据已经持久化了！这时候我们只需要加入一个后台线程进行补偿，定期的从转账流水表中读取状态为“待处理”且最后更新的时间距当前时间大于某个阈值的数据，重新放入消息队列进行补偿。这样，就保证了消息即使丢失，也会有补偿机制！B银行在处理完转账请求后会回调A银行的接口通知转账的状态，从而更新A银行流水表中的状态字段！这样就完美解决了上一个方案中的两个不足点。系统设计图如下：
   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190417210356.png)

   到目前为止，我们很好的解决了消息丢失的问题，保证了只要A银行转账操作成功，转账的请求就一定能发送到B银行！但是该方案又引入了一个问题，通过后台线程轮询将消息放入消息队列处理，同一次转账请求可能会出现多次放入消息队列而多次消费的情况，这样B银行会对同一转账多次处理导致数据出现不一致！那怎么保证B银行转账接口的幂等性呢？

   同样的，我们可以在B银行系统中需要增加一个转账日志表，或者叫转账流水表，B银行每次接收到转账请求，在对账户进行操作的时候同时往转账日志表中插入一条转账日志记录，同样这两个操作也必须是原子的！在接收到转账请求后，首先根据唯一转账流水Id在日志表中查找判断该转账是否已经处理过，如果未处理过则进行处理，否则直接回调返回！ 最终的架构图如下：
   ![img](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/WeChat%20Screenshot_20190416205100.png)

   所以，我们这里最核心的就是A银行通过**本地事务**保证日志记录+**后台线程轮询**保证消息不丢失。B银行通过**本地事务**保证日志记录从而保证消息不重复消费！B银行在回调A银行的接口时会通知处理结果，如果转账失败，A银行会根据处理结果进行回滚。











----

# 以银行装账为例分析分布式事务的解决方案

![image-20210707164143966](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164143966.png)

![image-20210707164215187](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164215187.png)



![image-20210707164232475](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164232475.png)

![image-20210707164248384](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164248384.png)

![image-20210707164303099](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164303099.png)

![image-20210707164316583](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164316583.png)

![image-20210707164328298](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164328298.png)

![image-20210707164337632](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164337632.png)

![image-20210707164351067](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164351067.png)

![image-20210707164400119](%E8%BD%AC%E8%B4%A6%E4%B8%9A%E5%8A%A1.assets/image-20210707164400119.png)

