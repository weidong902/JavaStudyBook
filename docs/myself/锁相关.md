# 锁相关：

* 乐观锁、悲观锁
* 死锁
* 公平锁、非公平锁。

乐观锁与悲观锁：可以类比为生活中的乐观和悲观。

# 乐观锁与悲观锁

## **一、悲观锁：**

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当别人要拿这个数据就会阻塞，直到它将锁释放（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁都是悲观锁的实现。

## **二、乐观锁 :**

总是假设好的情况，每次去拿数据的时候都认为别人不会修改，所以不上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。

乐观锁适用于多读的应用类型，可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

### 两种锁的使用场景:

两种锁各有优缺点，乐观锁适用于写比较少的情况下（多读场景），即冲突较少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但在多写的情况下，一般经常会发生冲突，这就会导致不断的进行重试反而降低了性能，因此悲观锁适合在多写的场景下。

### 乐观锁常见的两种实现方式

版本号机制或CAS算法实现乐观锁

**1. 版本号机制**

在表中增加一个版本号字段，表示数据被修改的次数，当数据被修改时version值就加1。更新前先查一遍获取版本号，再作为更新语句的where条件进行更新，如果在数据获取版本号之后，在更新之前version已经改变了，那么就更新失败，因为更新0条，后台拿到返回值为0，说明出现了并发数据已经被修改了。

举一个简单的例子： 

- 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。
- 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。
- 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。
- 操作员 A 完成了修改工作，将数据版本号加1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
- 操作员 B 完成了操作，也将版本号加1（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。
- 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

**2. CAS算法**

即Compare And Swap（比较、交换），是乐观锁的一种实现，无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。JUC中很多工具类的实现都是基于CAS。

CAS算法涉及到三个操作数：

1. 需要读写的内存值 V
2. 要进行比较的值 A
3. 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

### 乐观锁的缺点

ABA 问题是乐观锁一个常见的问题

**1 ABA 问题**

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

防止ABA的方法。（版本号，时间戳。）

```sql
update table set value = newValue ，vision = vision + 1 where value = #{oldValue} and vision = #{vision} 
# 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样
```

**2 循环时间长开销大**

自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

**3 只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

### **CAS与synchronized的使用情景**

简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重，Java SE 1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。

## **三、死锁 :** 

所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），当处于僵持状态时若无外力作用，将无法继续进行。例：线程A按照先锁定a再锁定b，线程B按照先锁定b再锁定a，在A线程锁定a的同时，B线程锁定b。

###  死锁产生的条件

（1）互斥条件。进程对所分配到的资源进行排他性使用，即在一段时间内，某资源只能被一个进程占用。如果此时还有其他进程请求该资源，则请求进程只能等待，直至占有该资源的进程用毕释放。 
（2）请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己以获得的资源保持不放。 
（3）不可抢占条件。进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放。 
（4）循环等待条件。在发生死锁时，必然存在一个进程—资源的循环链，即进程集合{P0,P1,P2,P3,…,Pn}中的P0正在等待P1占用的资源，P1正在等待P2占用的资源，… … ，Pn正在等待已被P0占用的资源。 

### 解决死锁的方法：

1、预防死锁： 破坏死锁的四个必要条件中的一个或多个来预防死锁。 

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

2、避免死锁： 和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。 
   a：加锁顺序（线程按照一定的顺序加锁）因为当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。 
   b：加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 
3、检测死锁： 首先为每个进程和每个资源指定唯一号码，然后建立资源分配表和进程等待表。
4、解除死锁： 发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。

## 四、公平锁与非公平锁

### 1、公平锁和非公平锁的定义：

#### **公平锁：**

公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

优点：所有的线程都能得到资源，不会饿死在队列中。

缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

#### 非公平锁：

非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。

缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。
















ReetrantLock默认是非公平锁

使用如下初始化转为公平锁

```java
ReentrantLock lock = new ReentrantLock(true);
```

